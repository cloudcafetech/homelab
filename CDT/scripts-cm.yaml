apiVersion: v1
kind: ConfigMap
metadata:
  name: start-up
  namespace: kubevirt-images
data:
  01-set-dns.sh: |
    #!/bin/bash
    
    # Define the configuration file
    CONFIG_FILE="/etc/NetworkManager/NetworkManager.conf"
    
    # Check if the file exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "Error: $CONFIG_FILE does not exist."
        exit 1
    fi
    
    # Check if dns=none is already present
    if grep -q "dns=none" "$CONFIG_FILE"; then
        echo "dns=none is already present in $CONFIG_FILE."
        exit 0
    fi
    
    # Insert dns=none after the [main] section
    sed -i '/^\[main\]/a dns=none' "$CONFIG_FILE"
    
    # Notify the user
    echo "Inserted 'dns=none' after [main] in $CONFIG_FILE."
    
    # Assign arguments to variables
    DNS1="192.66.185.8"
    DNS2="192.66.185.7"
    
    # set DNS
    
    echo "Setting DNS to $DNS1 and $DNS2 on interface $INTERFACE..."
    
    # Create a backup of the current configuration
    cp /etc/resolv.conf /etc/resolv.conf.bak
    
    cat > /etc/resolv.conf<< EOF
    # Generated by set_dns script
    search  nms.tdc.net ip.tele.dk adsl-dhcp.tele.dk tsm.tele.dk ip.tdk.dk eng.tdc.net
    options timeout:1 rotate
    nameserver $DNS1
    nameserver $DNS2
    EOF


  02-set-chrony.sh: |
    #!/bin/bash
    
    # Script to set up and start chrony with specific NTP servers
    # Usage: ./set-chrony.sh
    
    # NTP servers to use
    NTP_SERVERS=("ntp1.tele.dk" "ntp2.tele.dk" "ntp3.tele.dk")
    
    
    # Function to configure chrony
    configure_chrony() {
        echo "Configuring chrony to use NTP servers: ${NTP_SERVERS[*]}"
        
        # Backup the original chrony configuration
        sudo cp /etc/chrony.conf /etc/chrony.conf.bak
    
        # Clear existing server entries
        sudo sed -i '/^server /d' /etc/chrony.conf
    
        # Add the NTP servers to the configuration
        for server in "${NTP_SERVERS[@]}"; do
            echo "server $server iburst" | sudo tee -a /etc/chrony.conf
        done
    
        # Allow access from local network (optional, adjust as needed)
        echo "allow" | sudo tee -a /etc/chrony.conf
    }
    
    # Function to enable and start chronyd service
    enable_and_start_chronyd() {
        echo "Enabling and starting chronyd service..."
        sudo systemctl enable chronyd
        sudo systemctl start chronyd
    }
    
    # Function to check the status of chronyd
    check_chronyd_status() {
        echo "Checking chronyd service status..."
        sudo systemctl status chronyd
    }
    
    # Main script execution
    configure_chrony
    enable_and_start_chronyd
    check_chronyd_status
    
    echo "Chrony setup completed."


  03-set-subscription-manager.sh: |
    #!/bin/bash
    
    # Script to register a system with Red Hat Satellite
    # Usage: ./register_with_satellite.sh
    
    # Variables
    SATELLITE_URL="serverpatch02.nms.tdc.net"
    USERNAME="Adminuser"
    PASSWORD=`cat /mnt/secret-for-scripts/PASSWORD`
    ACTIVATION_KEY="ActivationKey_8"
    ORG="TekNet"
    ENVIRONMENT="Library"
    
    
    update_host_file() {
    
    # Define the IP address and hostnames
    
    IP_ADDRESS="95.166.240.14"
    
    HOSTNAME="serverpatch02.eng.tdc.net"
    
    ALIAS="serverpatch02"
    
    
    # Check if the entry already exists in /etc/hosts
    
    if grep -q "$IP_ADDRESS" /etc/hosts; then
    
        echo "Entry for $IP_ADDRESS already exists in /etc/hosts."
    
    else
    
        # Add the entry to /etc/hosts
    
        echo "$IP_ADDRESS $HOSTNAME $ALIAS" | sudo tee -a /etc/hosts > /dev/null
    
        echo "Added entry to /etc/hosts: $IP_ADDRESS $HOSTNAME $ALIAS"
    
    fi
    
    
    }
    
    # Function to register the system
    register_system() {
        curl --insecure --output katello-ca-consumer-latest.noarch.rpm https://serverpatch02.eng.tdc.net/pub/katello-ca-consumer-latest.noarch.rpm 
        yum localinstall katello-ca-consumer-latest.noarch.rpm -y
    
        echo "Registering the system with Red Hat Satellite..."
    
        # Register the system
        sudo subscription-manager register --username="$USERNAME" --password="$PASSWORD" --org="$ORG" --environment="$ENVIRONMENT" --insecure
    
        if [ $? -eq 0 ]; then
            echo "System registered successfully."
        else
            echo "Failed to register the system."
            exit 1
        fi
    }
    
    # Function to enable repositories (optional)
    enable_repositories() {
    
        subscription-manager repos --disable="*"
        echo "Enabling repositories..."
    
        # Enable necessary repositories (modify as needed)
        sudo subscription-manager repos --enable=rhel-9-for-x86_64-baseos-rpms
        sudo subscription-manager repos --enable=rhel-9-for-x86_64-appstream-rpms
    
        if [ $? -eq 0 ]; then
            echo "Repositories enabled successfully."
        else
            echo "Failed to enable repositories."
            exit 1
        fi
    }
    
    # Main script execution
    update_host_file
    register_system
    enable_repositories
    
    echo "Registration and repository setup completed."


  04-patch-rhel9.sh: |
    #!/bin/bash
    
    # Script to patch RHEL 8
    # Usage: ./patch_rhel9.sh
    
    # Variables
    LOGFILE="/var/log/patch_rhel9.log"
    DATE=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Function to log messages
    log_message() {
        echo "$DATE - $1" | tee -a "$LOGFILE"
    }
    
    # Function to update the system
    update_system() {
        log_message "Starting system update..."
        
        # Update the package manager cache
        sudo dnf makecache
    
        # Perform the update
        sudo dnf -y update
    
        if [ $? -eq 0 ]; then
            log_message "System updated successfully."
        else
            log_message "Failed to update the system."
            exit 1
        fi
    }
    
    # Function to check for and apply security updates
    apply_security_updates() {
        log_message "Checking for security updates..."
    
        # List available security updates
        SECURITY_UPDATES=$(sudo dnf updateinfo list security | grep -v "No packages" | wc -l)
    
        if [ "$SECURITY_UPDATES" -gt 0 ]; then
            log_message "$SECURITY_UPDATES security updates available. Applying updates..."
            
            # Apply security updates
            sudo dnf -y update --security
    
            if [ $? -eq 0 ]; then
                log_message "Security updates applied successfully."
            else
                log_message "Failed to apply security updates."
                exit 1
            fi
        else
            log_message "No security updates available."
        fi
    }
    
    
    # Main script execution
    log_message "Starting patching process..."
    update_system
    apply_security_updates
    log_message "Patching process completed."


  05-tools-downloader-installer.sh: |
    #!/bin/bash
    sudo yum -y install vim
    sudo yum -y install git
    sudo yum -y install net-tools

    sudo yum -y install unzip

    # Define the URL of the GitLab repository (without the .git extension)
    repoUrl="https://p-boss-gitlab-01.eng.tdc.net//public-repositories/shared-services/vm-tools/epic_tools_linux"

    # Define the destination path where you want to save the ZIP file
    zipFilePath="/tmp/epic_tools_linux.zip"

    # Define the extraction path
    extractionPath="/install"

    # Construct the ZIP download URL
    # Note: Replace 'main' with the default branch name if it's different
    zipDownloadUrl="$repoUrl/-/archive/main/epic_tools_linux-main.zip"


    # Download the ZIP file with the access token
    echo "Downloading the repository..."
    if curl -L -o "$zipFilePath" "$zipDownloadUrl"; then
        echo "Download completed successfully."
    else
        echo "Failed to download the repository."
        exit 1
    fi

    # Check if the ZIP file was downloaded successfully
    if [[ -f "$zipFilePath" ]]; then
        # Create the extraction directory if it doesn't exist
        mkdir -p "$extractionPath"
    
        # Extract the ZIP file
        echo "Extracting the repository..."
        if unzip -o "$zipFilePath" -d "$extractionPath"; then
            echo "Repository extracted successfully."
    
            # Optionally, remove the ZIP file after extraction
            rm -f "$zipFilePath"
            echo "Cleaned up the ZIP file."
        else
            echo "Failed to extract the ZIP file."
            exit 1
        fi
    else
        echo "ZIP file not found."
        exit 1
    fi
    
    # Clean up
    rm -f "$ZIP_FILE"
    echo "Script completed successfully."

    # Install the tools RPMS
    rpm -ivh /install/epic_tools_linux-main/Redhat_Linux_9/Tanium/TaniumClient-7.6.2.1218-1.rhe9.x86_64.rpm
    cp /install/epic_tools_linux-main/Redhat_Linux_9/Tanium/tanium-init.dat /opt/Tanium/TaniumClient/
    rpm -ivh /install/epic_tools_linux-main/Redhat_Linux_9/Sentinelone/SentinelAgent_linux_x86_64_v24_2_2_20.rpm
    sentinelctl management token set eyJ1cmwiOiAiaHR0cHM6Ly9ldWNlMS10ZGNuZXQuc2VudGluZWxvbmUubmV0IiwgInNpdGVfa2V5IjogIjczMjA0ZTA1YzcwZGQ0N2QifQ==
    rpm -ivh /install/epic_tools_linux-main/Redhat_Linux_9/Rapid7/rapid7-insight-agent-4.0.12.14-1.x86_64.rpm
    rpm -ivh /install/epic_tools_linux-main/Redhat_Linux_9/Flexera/managesoft-18.0.0-1.x86_64.rpm
    unzip /install/epic_tools_linux-main/Redhat_Linux_9/DS_agent/Agent-RedHat_EL9-20.0.1-21510.x86_64.zip -d /install/epic_tools_linux-main/Redhat_Linux_9/DS_AGENT/
    rpm -ivh /install/epic_tools_linux-main/Redhat_Linux_9/DS_AGENT/Agent-Core-RedHat_EL9-20.0.1-21510.x86_64.rpm
    rm -rf /install/epic_tools_linux-main    

  06-set-firewall.sh: |
    #!/bin/bash
    
    # Script to configure the firewall and set SELinux to permissive mode on RHEL
    # Usage: ./configure_firewall_and_selinux.sh
    
    # Function to enable the firewall
    enable_firewall() {
        echo "Enabling the firewall..."
        sudo systemctl start firewalld
        sudo systemctl enable firewalld
    }
    
    # Function to set the default zone to drop
    set_default_zone() {
        echo "Setting default zone to 'drop'..."
        sudo firewall-cmd --set-default-zone=drop
    }
    
    # Function to allow SSH service
    allow_ssh() {
        echo "Allowing SSH service..."
        sudo firewall-cmd --zone=drop --add-service=ssh --permanent
    }
    
    # Function to reload the firewall to apply changes
    reload_firewall() {
        echo "Reloading the firewall..."
        sudo firewall-cmd --reload
    }
    
    # Function to set SELinux to permissive mode
    set_selinux_permissive() {
        echo "Setting SELinux to permissive mode..."
        sudo setenforce 0  # Set SELinux to permissive mode immediately
        # Update SELinux configuration to make it persistent across reboots
        sudo sed -i 's/^SELINUX=.*/SELINUX=permissive/' /etc/selinux/config
    }
    
    # Main script execution
    enable_firewall
    set_default_zone
    allow_ssh
    reload_firewall
    set_selinux_permissive
    
    echo "Firewall and SELinux configuration completed. Only SSH service is allowed, and SELinux is in permissive mode."


  08-off-subscription-manager.sh: |
    #!/bin/bash
    
    # Script to unregister from Red Hat Satellite
    # Usage: ./unregister_from_satellite.sh
    
    # Function to unregister the system
    unregister_system() {
        echo "Unregistering the system from Red Hat Satellite..."
        
        # Unregister the system
        sudo subscription-manager unregister
    
        if [ $? -eq 0 ]; then
            echo "Successfully unregistered from Red Hat Satellite."
        else
            echo "Failed to unregister from Red Hat Satellite."
            exit 1
        fi
    }
    
    # Function to remove subscription-manager configurations (optional)
    remove_subscription_manager_configs() {
        echo "Removing subscription-manager configurations..."
        
        # Remove the cache files
        sudo yum clean all;yum repolist
       
       
        echo "Subscription-manager configurations removed."
    }
    
    # Main script execution
    unregister_system
    remove_subscription_manager_configs  # Uncomment if you want to remove configurations
    
    echo "Unregistration from Red Hat Satellite completed."


  09-logbase-line.sh: |
    #!/bin/bash
    
    log_baseline() {
    # Define the rsyslog configuration file
    RSYSLOG_CONF="/etc/rsyslog.d/99-custom-logging.conf"
    
    # Create or overwrite the configuration file
    echo "Configuring rsyslog to log specified facilities and severity levels..."
    
    # Add logging rules to the configuration file
    cat <<EOL > "$RSYSLOG_CONF"
    # Custom logging configuration
    *.*;auth,authpriv.none -/var/log/syslog
    *.*;mail.none -/var/log/mail.log
    
    # Enable logging for specified facilities and severity levels
    syslog.warn;syslog.err;syslog.crit;syslog.emerg;syslog.info /var/log/syslog
    cron.crit;cron.info /var/log/cron.log
    daemon.info;daemon.emerg /var/log/daemon.log
    kern.crit;kern.emerg /var/log/kern.log
    mail.emerg;mail.info /var/log/mail.log
    user.* /var/log/user.log
    uucp.crit;uucp.emerg /var/log/uucp.log
    local0.emerg;local0.crit /var/log/local0.log
    local1.emerg;local1.crit /var/log/local1.log
    local2.emerg;local2.crit /var/log/local2.log
    local3.emerg;local3.crit /var/log/local3.log
    local4.emerg;local4.crit /var/log/local4.log
    local5.emerg;local5.crit /var/log/local5.log
    local6.emerg;local6.crit /var/log/local6.log
    local7.emerg;local7.crit /var/log/local7.log
    EOL
    
    # Restart rsyslog service to apply changes
    echo "Restarting rsyslog service..."
    systemctl restart rsyslog
    
    echo "Rsyslog configuration updated successfully."
    
    }
    
    if [ "$EUID" -ne 0 ]; then
        echo "Please run as root"
        exit 1
    fi
    
    
    log_history() {
    # Define the entries to be added
    HISTSIZE="export HISTSIZE=20480"
    HISTFILE="export HISTFILE=/var/log/history/history_\$(uname -n)_\$(date +%Y:%b:%d:%H:%M)_\$(who am i | awk '{print \$1}')"
    PROMPT_COMMAND="export PROMPT_COMMAND='history -a'"
    PS1="export PS1='\\\${LOGNAME}@\$(hostname):\$PWD>'"
    
    # Check if the entries already exist in /etc/profile
    if ! grep -q "$HISTSIZE" /etc/profile; then
        echo "$HISTSIZE" >> /etc/profile
        echo "Added: $HISTSIZE"
    fi
    
    if ! grep -q "$HISTFILE" /etc/profile; then
        echo "$HISTFILE" >> /etc/profile
        echo "Added: $HISTFILE"
    fi
    
    if ! grep -q "$PROMPT_COMMAND" /etc/profile; then
        echo "$PROMPT_COMMAND" >> /etc/profile
        echo "Added: $PROMPT_COMMAND"
    fi
    
    if ! grep -q "$PS1" /etc/profile; then
        echo "$PS1" >> /etc/profile
        echo "Added: $PS1"
    fi
    
    echo "Profile updated. Please log out and log back in for changes to take effect."
    
    }
    
    bash_history() {
    # Check if the script is run as root
    if [ "$EUID" -ne 0 ]; then
        echo "Please run as root"
        exit 1
    fi
    
    # Define the entries to be added
    PORT="PORT=\`who am i | awk '{ print \$5 }' | sed 's/(//g' | sed 's/)//g'\`"
    LOGGER="logger -p local3.notice -t \"bash \$LOGNAME \$\$\" User \$LOGNAME logged from \$PORT"
    FUNCTION="function history_to_syslog {"
    FUNCTION_BODY="\
        declare cmd\n\
        declare p_dir\n\
        declare LOG_NAME\n\
        cmd=\$(history 1)\n\
        cmd=\$(echo \$cmd | awk '{print substr(\$0,length(\$1)+2)}')\n\
        p_dir=\$(pwd)\n\
        LOG_NAME=\$(echo \$LOGNAME)\n\
        if [ \"\$cmd\" != \"\$old_command\" ]; then\n\
            logger -p local3.notice -- SESSION = \$\$, from_remote_host = \$PORT, USER = \$LOG_NAME, PWD = \$p_dir, CMD = \"\${cmd}\"\n\
        fi\n\
        old_command=\$cmd\n\
    }"
    TRAP="trap history_to_syslog DEBUG || EXIT"
    
    # Check if the entries already exist in /etc/bashrc
    if ! grep -q "$PORT" /etc/bashrc; then
        echo "$PORT" >> /etc/bashrc
        echo "Added: $PORT"
    fi
    
    if ! grep -q "$LOGGER" /etc/bashrc; then
        echo "$LOGGER" >> /etc/bashrc
        echo "Added: $LOGGER"
    fi
    
    if ! grep -q "function history_to_syslog" /etc/bashrc; then
        echo -e "$FUNCTION" >> /etc/bashrc
        echo "Added: $FUNCTION"
    fi
    
    # Add the function body
    if ! grep -q "old_command=" /etc/bashrc; then
        echo -e "$FUNCTION_BODY" >> /etc/bashrc
        echo "Added function body for history_to_syslog"
    fi
    
    if ! grep -q "$TRAP" /etc/bashrc; then
        echo "$TRAP" >> /etc/bashrc
        echo "Added: $TRAP"
    fi
    
    echo "Bashrc updated. Please log out and log back in for changes to take effect."
    
    }
    
    # Main script execution
    log_baseline
    log_history
    bash_history


  10-log_rotate.sh: |
    #!/bin/bash
    logrotate(){
    # Define the logrotate configuration file path
    LOGROTATE_CONF="/etc/logrotate.conf"
    
    # Create or overwrite the logrotate configuration file
    echo "Creating logrotate configuration at $LOGROTATE_CONF..."
    
    cat <<EOL > "$LOGROTATE_CONF"
    # see "man logrotate" for details
    
    # Rotate log files weekly
    weekly
    
    # Keep 4 weeks worth of backlogs
    rotate 4
    
    # Create new (empty) log files after rotating old ones
    create
    
    # Use date as a suffix of the rotated file
    dateext
    
    # Uncomment this if you want your log files compressed
    compress
    
    # RPM packages drop log rotation information into this directory
    include /etc/logrotate.d
    
    # No packages own wtmp and btmp -- we'll rotate them here
    /var/log/wtmp {
        monthly
        create 0664 root utmp
        rotate 13
    }
    
    /var/log/btmp {
        missingok
        monthly
        create 0600 root utmp
        rotate 13
    }
    EOL
    
    # Set appropriate permissions for the configuration file
    chmod 644 "$LOGROTATE_CONF"
    chown root:root "$LOGROTATE_CONF"
    
    echo "Logrotate configuration created successfully."
    
    }
    
    custom_logrotate() {
    # Check if the script is run as root
    if [ "$EUID" -ne 0 ]; then
        echo "Please run as root"
        exit 1
    fi
    
    # Define the log files and their corresponding logrotate configuration
    declare -A log_files=(
        [commands]="/var/log/commands"
        [cron.crit]="/var/log/cron.crit"
        [daemon]="/var/log/daemon"
        [kernlog]="/var/log/kernlog"
        [local.crit]="/var/log/local.crit"
        [local.emerg]="/var/log/local.emerg"
        [mail.emerg]="/var/log/mail.emerg"
        [user]="/var/log/user"
    )
    
    # Create logrotate configuration for each log file
    for log_name in "${!log_files[@]}"; do
        config_file="/etc/logrotate.d/$log_name"
    
        # Check if the configuration file already exists
        if [ -f "$config_file" ]; then
            echo "Logrotate configuration for $log_name already exists. Skipping."
            continue
        fi
    
        # Create the logrotate configuration
        echo "Creating logrotate configuration for $log_name..."
        {
            echo "${log_files[$log_name]} {"
            echo "    missingok"
            echo "    sharedscripts"
            echo "    postrotate"
            echo "        /bin/kill -HUP \$(cat /var/run/syslogd.pid 2> /dev/null) 2> /dev/null || true"
            echo "    endscript"
            echo "}"
        } > "$config_file"
    done
    
    echo "Logrotate configurations created successfully."
    
    }
    

  11-system-cleanup.sh: |
    #!/bin/bash
    
    # Script to zero out hostname, machine ID, host ID, logs, and command history
    # Usage: ./cleanup_system.sh
    
    # Function to reset the hostname
    reset_hostname() {
        echo "Resetting hostname..."
        # Set hostname to localhost
        sudo hostnamectl set-hostname localhost
        echo "Hostname reset to 'localhost'."
    }
    
    # Function to zero out the machine ID
    zero_machine_id() {
        echo "Zeroing out machine ID..."
        echo -n "" | sudo tee /etc/machine-id > /dev/null
        echo "Machine ID zeroed out."
    }
    
    # Function to zero out the host ID
    zero_hostid() {
        echo "Zeroing out host ID..."
        echo -n "00000000" | sudo tee /etc/hostid > /dev/null
        echo "Host ID zeroed out."
    }
    
    # Function to zero out logs
    zero_logs() {
        echo "Zeroing out logs..."
        # Zero out log files in /var/log
        sudo find /var/log -type f -exec sh -c 'cat /dev/null > "$1"' _ {} \;
        echo "Logs zeroed out."
    }
    
    # Function to clear command history
    clear_history() {
        echo "Clearing command history..."
        # Clear the history for the current session
        history -c
        # Zero out the history file
        echo -n "" > ~/.bash_history
        echo "Command history cleared."
    }
    
    # Main script execution
    reset_hostname
    zero_machine_id
    zero_hostid
    zero_logs
    clear_history
    
    echo "Cleanup completed."
